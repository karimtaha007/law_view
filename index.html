<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=no">
  <title>Floor Plan Signal Analysis - Professional View</title>
  <style>
    /* ===== RESET & BASE ===== */
    * { 
      box-sizing: border-box; 
      margin: 0; 
      padding: 0; 
      -webkit-tap-highlight-color: transparent; 
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      height: 100vh;
      width: 100vw;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    /* ===== HEADER ===== */
    .header {
      background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
      height: 60px;
      padding: 0 15px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 3px solid #e94560;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0,0,0,0.4);
      flex-shrink: 0;
    }
    
    .header h1 {
      color: #00ff88;
      font-size: 18px;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 10px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    
    .count-badge {
      background: linear-gradient(135deg, #e94560 0%, #ff6b88 100%);
      color: white;
      font-size: 12px;
      font-weight: 700;
      padding: 4px 10px;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(233, 69, 96, 0.3);
      margin-left: 8px;
    }

    /* ===== ZOOM CONTROLS ===== */
    .controls {
      display: flex;
      gap: 8px;
    }
    
    .btn {
      background: #0f3460;
      color: white;
      border: 1px solid rgba(255,255,255,0.1);
      width: 36px;
      height: 36px;
      border-radius: 8px;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    
    .btn:active { 
      background: #e94560; 
      transform: scale(0.95);
    }
    
    .btn.reset-btn { 
      width: auto; 
      padding: 0 12px; 
      font-size: 12px;
      font-weight: 600;
    }

    /* ===== VIEWPORT ===== */
    #viewport {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: #e0e0e0; /* Lighter background for better contrast against map edges */
      touch-action: none;
      cursor: grab;
      box-shadow: inset 0 0 30px rgba(0,0,0,0.2);
    }
    
    #viewport.grabbing { cursor: grabbing; }

    /* ===== MAP CONTAINER & IMAGE ===== */
    #map-container {
      position: absolute;
      top: 0; left: 0;
      transform-origin: 0 0;
      will-change: transform;
    }
    
    #floorImage {
      display: block;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
    }

    /* ===== POINTS (FIXED VISIBILITY) ===== */
    .point {
      position: absolute;
      /* High Contrast Colors */
      background: #ffffff; 
      border: 3px solid #e94560; 
      color: #000000; /* Black Text for readability */
      
      border-radius: 50%;
      transform: translate(-50%, -50%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 900; /* Extra Bold */
      font-family: Arial, sans-serif;
      cursor: pointer;
      z-index: 10;
      transition: transform 0.2s, background 0.2s;
      /* distinct shadow to pop off the map */
      box-shadow: 0 4px 8px rgba(0,0,0,0.5); 
    }

    .point:hover {
      transform: translate(-50%, -50%) scale(1.1);
      background: #ffecec;
    }

    .point.active {
      background: #00ff88;
      border-color: #0f3460;
      color: #0f3460;
      z-index: 20;
      box-shadow: 0 0 0 4px rgba(0, 255, 136, 0.4), 0 8px 16px rgba(0,0,0,0.6);
      transform: translate(-50%, -50%) scale(1.3) !important;
    }

    /* ===== INFO POPUP (RESPONSIVE FIX) ===== */
    .info-sheet {
      position: fixed;
      z-index: 1000;
      background: linear-gradient(180deg, #16213e 0%, #0f3460 100%);
      border: 2px solid #e94560;
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 8px 40px rgba(0,0,0,0.7);
      
      /* Animation */
      transform: scale(0.9) translateY(20px);
      opacity: 0;
      pointer-events: none;
      transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
      
      /* Desktop Default Position */
      bottom: 20px;
      right: 20px;
      width: 300px;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
    }
    
    .info-sheet.open { 
      transform: scale(1) translateY(0);
      opacity: 1;
      pointer-events: auto;
    }

    .sheet-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(233, 69, 96, 0.3);
      flex-shrink: 0;
    }

    .plate-title {
      font-size: 14px;
      color: #00ff88;
      font-weight: 700;
    }
    
    .plate-id {
      background: #e94560;
      color: white;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      font-weight: 800;
      margin-right: 8px;
    }

    .close-sheet {
      background: rgba(255,255,255,0.1);
      border: none;
      color: white;
      width: 24px; 
      height: 24px;
      border-radius: 50%;
      font-size: 18px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Scrollable content area for the table */
    .sheet-scroll-area {
      overflow-y: auto;
      /* Custom Scrollbar */
      scrollbar-width: thin;
      scrollbar-color: #e94560 #0f3460;
    }
    
    .sheet-scroll-area::-webkit-scrollbar {
      width: 6px;
    }
    .sheet-scroll-area::-webkit-scrollbar-thumb {
      background-color: #e94560;
      border-radius: 3px;
    }

    .data-grid {
      display: grid;
      /* Dynamic columns: fit as many as possible, minimum 85px wide */
      grid-template-columns: repeat(auto-fit, minmax(85px, 1fr));
      gap: 8px;
      padding-right: 4px; /* Space for scrollbar */
    }

    .signal-box {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 6px;
      padding: 8px;
      text-align: center;
    }

    .signal-box.main-signal {
      grid-column: 1 / -1; /* Full width */
      background: rgba(15, 52, 96, 0.6);
      border: 1px solid #00ff88;
      margin-bottom: 4px;
    }

    .signal-name {
      font-size: 10px;
      color: #aebbd4;
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    .signal-value {
      font-weight: 700;
      font-family: 'Courier New', monospace;
      font-size: 16px;
    }
    
    .signal-box.main-signal .signal-value {
      font-size: 22px;
    }

    .val-green { color: #00ff88; }
    .val-yellow { color: #ffaa00; }
    .val-red { color: #ff4d4d; }

    /* ===== STATUS MESSAGE ===== */
    #status-msg {
      position: absolute;
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.85);
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      z-index: 2000;
      pointer-events: none;
      border: 1px solid #e94560;
    }
    #status-msg.hidden { display: none; }

    /* ===== MOBILE RESPONSIVE TWEAKS ===== */
    @media (max-width: 600px) {
      .header h1 span:first-child { display: none; } /* Hide icon on small screens */
      
      .btn.reset-btn { 
        display: none; /* Hide reset text button on mobile to save space */
      }

      /* Mobile Info Sheet Logic */
      .info-sheet {
        width: 92%; /* Do not take full width */
        left: 4%; /* Center it */
        right: auto;
        bottom: 15px;
        
        /* Limit height so it doesn't cover the whole map */
        max-height: 40vh; 
      }
      
      .data-grid {
        grid-template-columns: repeat(2, 1fr); /* Force 2 columns on small screens */
      }
    }
  </style>
</head>
<body>

  <div class="header">
    <h1>
      <span>üì°</span>
      <span>Signal Analysis</span>
      <span class="count-badge" id="plateCount">0</span>
    </h1>
    <div class="controls">
      <button class="btn reset-btn" id="btnReset">Reset View</button>
      <button class="btn" id="btnFit" title="Fit to screen">‚õ∂</button>
      <button class="btn" id="btnPlus" title="Zoom in">Ôºã</button>
      <button class="btn" id="btnMinus" title="Zoom out">Ôºç</button>
    </div>
  </div>

  <div id="viewport">
    <div id="map-container">
      <img id="floorImage" src="floor1.jpg" alt="Floor Plan">
    </div>
    <div id="status-msg">‚è≥ Loading Map Data...</div>
  </div>

  <div class="info-sheet" id="infoSheet">
    <div class="sheet-header">
      <div>
        <span class="plate-id" id="sheetId">#1</span>
        <span class="plate-title" id="sheetName">Point</span>
      </div>
      <button class="close-sheet" id="closeSheet">√ó</button>
    </div>
    
    <div class="sheet-scroll-area">
      <div class="data-grid" id="sheetContent">
        </div>
    </div>
  </div>

<script>
  // ===== CONFIGURATION =====
  const CONFIG = {
    minScale: 0.1,
    maxScale: 10,
    zoomStep: 1.3,
    imageSrc: 'floor1.jpg',
    dataSrc: 'floor_full_data.json'
  };

  // ===== STATE =====
  let state = {
    scale: 1,
    x: 0,
    y: 0,
    isDragging: false,
    startX: 0,
    startY: 0,
    points: [],
    initialViewport: null,
    defaultPointSize: 28 // Increased default size for better visibility
  };

  // ===== DOM ELEMENTS =====
  const els = {
    viewport: document.getElementById('viewport'),
    container: document.getElementById('map-container'),
    img: document.getElementById('floorImage'),
    sheet: document.getElementById('infoSheet'),
    status: document.getElementById('status-msg'),
    count: document.getElementById('plateCount')
  };

  // ===== INITIALIZATION =====
  function init() {
    els.img.onload = () => {
      console.log("Image loaded.");
      loadPointsData();
    };
    
    els.img.onerror = () => {
      els.status.innerHTML = "‚ùå <b>Error</b><br>floor1.jpg not found";
      els.status.classList.remove('hidden');
    };

    if (els.img.complete && els.img.naturalWidth > 0) {
      loadPointsData();
    }

    setupEventListeners();
  }

  // ===== LOAD DATA =====
  async function loadPointsData() {
    try {
      const response = await fetch(CONFIG.dataSrc);
      if (!response.ok) throw new Error("Data file not found");
      const data = await response.json();
      
      if (Array.isArray(data)) {
        state.points = data;
        fitMapToScreen();
      } else {
        state.points = data.points || [];
        if (data.viewportConfig) {
          state.initialViewport = data.viewportConfig;
          state.defaultPointSize = data.viewportConfig.pointSize || 28;
          applyInitialViewport();
        } else {
          fitMapToScreen();
        }
      }

      els.count.textContent = state.points.length;
      els.status.classList.add('hidden');
      renderPoints();
      
    } catch (err) {
      console.error(err);
      els.status.innerHTML = `‚ö†Ô∏è <b>No Data</b><br><small>Check console</small>`;
      els.status.classList.remove('hidden');
      fitMapToScreen();
    }
  }

  function applyInitialViewport() {
    if (!state.initialViewport) { fitMapToScreen(); return; }
    state.scale = state.initialViewport.scale || 1;
    state.x = state.initialViewport.x || 0;
    state.y = state.initialViewport.y || 0;
    updateTransform();
  }

  // ===== RENDER POINTS =====
  function renderPoints() {
    document.querySelectorAll('.point').forEach(p => p.remove());

    state.points.forEach(p => {
      const el = document.createElement('div');
      el.className = 'point';
      el.textContent = p.row; // The number inside the point
      
      el.style.left = p.x + 'px';
      el.style.top = p.y + 'px';
      
      // Store base size for scaling logic
      el.dataset.baseSize = p.size || state.defaultPointSize;
      
      el.addEventListener('click', (e) => {
        e.stopPropagation();
        openSheet(p, el);
      });

      els.container.appendChild(el);
    });
    
    updatePointScale();
  }

  // ===== TRANSFORM & SCALING =====
  function updateTransform() {
    els.container.style.transform = `translate(${state.x}px, ${state.y}px) scale(${state.scale})`;
    updatePointScale();
  }

  function updatePointScale() {
    // Inverse scaling keeps points readable when zoomed out
    // But we cap it so they don't get ridiculously huge or tiny
    const inverseScale = 1 / state.scale;
    
    document.querySelectorAll('.point').forEach(el => {
      const baseSize = parseInt(el.dataset.baseSize);
      
      // Calculate scaled size
      let size = baseSize * inverseScale;
      
      // Clamp size limits (Min 20px, Max 80px visual size)
      // This ensures they are always clickable but not overwhelming
      if (size < 20) size = 20; 
      // if (size > 100) size = 100; // Optional cap
      
      el.style.width = size + 'px';
      el.style.height = size + 'px';
      
      // Scale font size relative to bubble size
      el.style.fontSize = (size * 0.5) + 'px';
      el.style.borderWidth = Math.max(2, size * 0.1) + 'px';
    });
  }

  function fitMapToScreen() {
    const vw = els.viewport.clientWidth;
    const vh = els.viewport.clientHeight;
    const iw = els.img.naturalWidth || 2000;
    const ih = els.img.naturalHeight || 2000;

    const scaleW = vw / iw;
    const scaleH = vh / ih;
    state.scale = Math.min(scaleW, scaleH) * 0.95;
    
    state.x = (vw - iw * state.scale) / 2;
    state.y = (vh - ih * state.scale) / 2;
    
    updateTransform();
  }

  // ===== INTERACTION HANDLERS =====
  function setupEventListeners() {
    // Mouse
    els.viewport.addEventListener('mousedown', e => {
      if(e.target.closest('.point')) return;
      state.isDragging = true;
      state.startX = e.clientX - state.x;
      state.startY = e.clientY - state.y;
      els.viewport.classList.add('grabbing');
    });

    window.addEventListener('mousemove', e => {
      if (!state.isDragging) return;
      e.preventDefault();
      state.x = e.clientX - state.startX;
      state.y = e.clientY - state.startY;
      updateTransform();
    });

    window.addEventListener('mouseup', () => {
      state.isDragging = false;
      els.viewport.classList.remove('grabbing');
    });

    // Zoom
    els.viewport.addEventListener('wheel', e => {
      e.preventDefault();
      const factor = e.deltaY > 0 ? 0.9 : 1.1;
      const rect = els.viewport.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      
      zoomToPoint(mx, my, factor);
    }, { passive: false });

    // Touch
    let lastTouchDist = 0;
    els.viewport.addEventListener('touchstart', e => {
      if (e.touches.length === 1) {
        state.isDragging = true;
        state.startX = e.touches[0].clientX - state.x;
        state.startY = e.touches[0].clientY - state.y;
      } else if (e.touches.length === 2) {
        state.isDragging = false;
        lastTouchDist = getDist(e.touches);
      }
    }, {passive: false});

    els.viewport.addEventListener('touchmove', e => {
      e.preventDefault();
      if (e.touches.length === 1 && state.isDragging) {
        state.x = e.touches[0].clientX - state.startX;
        state.y = e.touches[0].clientY - state.startY;
        updateTransform();
      } else if (e.touches.length === 2) {
        const dist = getDist(e.touches);
        const center = getCenter(e.touches);
        const factor = dist / lastTouchDist;
        const rect = els.viewport.getBoundingClientRect();
        
        zoomToPoint(center.x - rect.left, center.y - rect.top, factor);
        lastTouchDist = dist;
      }
    }, {passive: false});

    els.viewport.addEventListener('touchend', () => state.isDragging = false);

    // Buttons
    document.getElementById('btnPlus').onclick = () => zoomAtCenter(CONFIG.zoomStep);
    document.getElementById('btnMinus').onclick = () => zoomAtCenter(1 / CONFIG.zoomStep);
    document.getElementById('btnFit').onclick = fitMapToScreen;
    document.getElementById('btnReset').onclick = () => state.initialViewport ? applyInitialViewport() : fitMapToScreen();
    document.getElementById('closeSheet').onclick = closeSheet;
    els.viewport.addEventListener('click', closeSheet);
  }

  // ===== MATH HELPERS =====
  const getDist = (touches) => Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
  const getCenter = (touches) => ({ x: (touches[0].clientX + touches[1].clientX) / 2, y: (touches[0].clientY + touches[1].clientY) / 2 });

  function zoomToPoint(mx, my, factor) {
    const oldScale = state.scale;
    let newScale = state.scale * factor;
    newScale = Math.max(CONFIG.minScale, Math.min(CONFIG.maxScale, newScale));
    
    state.x = mx - (mx - state.x) * (newScale / oldScale);
    state.y = my - (my - state.y) * (newScale / oldScale);
    state.scale = newScale;
    updateTransform();
  }

  function zoomAtCenter(factor) {
    const rect = els.viewport.getBoundingClientRect();
    zoomToPoint(rect.width/2, rect.height/2, factor);
  }

  // ===== INFO SHEET LOGIC =====
  function openSheet(data, element) {
    document.querySelectorAll('.point.active').forEach(p => p.classList.remove('active'));
    element.classList.add('active');

    document.getElementById('sheetId').textContent = '#' + data.row;
    document.getElementById('sheetName').textContent = data.plate || 'Measurement Point';
    
    const container = document.getElementById('sheetContent');
    container.innerHTML = '';

    if (data.signals && Object.keys(data.signals).length > 0) {
      const entries = Object.entries(data.signals);
      entries.forEach(([key, val], index) => {
        const colorClass = getSignalColor(val);
        const isMain = index === 0;
        
        const box = document.createElement('div');
        box.className = `signal-box ${isMain ? 'main-signal' : ''}`;
        box.innerHTML = `<div class="signal-name">${key}</div><div class="signal-value ${colorClass}">${val}</div>`;
        container.appendChild(box);
      });
    } else {
      container.innerHTML = `<div style="grid-column:1/-1;text-align:center;color:#aaa;padding:10px;font-size:12px;">No signal data available</div>`;
    }

    els.sheet.classList.add('open');
  }

  function getSignalColor(value) {
    if (value > -45) return 'val-green';
    if (value >= -80) return 'val-yellow';
    return 'val-red';
  }

  function closeSheet() {
    els.sheet.classList.remove('open');
    document.querySelectorAll('.point.active').forEach(p => p.classList.remove('active'));
  }

  // Start
  init();
</script>
</body>
</html>